<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STEALTH ADDRESSES</title>

    <style>
        body {
            /* background-color: rgb(0, 72, 105)!important; */
            color: green;
        }

        #result {
            word-wrap: break-word;

        }
    </style>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <script src="js/sweetalert2.all.min.js"></script>

    <style>
        body {
            background-color: black;
            color: green;
        }

        input {
            font-size: x-small;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .container {
            width: 100%;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .col {
            flex: 1;
            min-width: 300px;
            padding: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
        }

        .form-group input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }

        .addresses {
            width: 350px !important;
        }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        .half-width {
            width: 50%;
        }

        .addr {
            font-size: x-small;
        }

        #result {
            font-size: xx-small;
        }

        /* COLORED TOAST */
        .colored-toast.swal2-icon-success {
            background-color: #45bb00 !important;
        }

        .colored-toast.swal2-icon-error {
            background-color: #f27474 !important;
        }

        .colored-toast.swal2-icon-warning {
            background-color: #f8bb86 !important;
        }

        .colored-toast.swal2-icon-info {
            background-color: #3fc3ee !important;
        }

        .colored-toast.swal2-icon-question {
            background-color: #87adbd !important;
        }

        .colored-toast .swal2-title {
            color: white;
        }

        .colored-toast .swal2-close {
            color: white;
        }

        .colored-toast .swal2-html-container {
            color: white;
        }
    </style>
</head>

<body>
    <h1>STEALTH ADDRESSES **G**</h1>
    <p>using SA between peers</p>


    <!-- Segunda fila con dos columnas -->
    <div class="row">
        <!-- Columna A - ALICE -->
        <div class="col">
            <h3>ALICE</h3>
            <span id="aliceAddress" class="addr"></span>
            <br>
            <span id="aliceSharedSecret" class="addr"></span>
            <span id="aliceBalance" class="balance"></span>
            <span id="aliceGas" class="balance"></span>


            <fieldset role="group">
                <input type="number" id="aliceAmount" placeholder="Amount to send" step="0.01" min="0" required>
                <input type="button" id="sendButton" value="Send to stealth address" />
            </fieldset>


        </div>

        <!-- Columna B - BOB -->
        <div class="col">
            <h3>BOB</h3>
            <span id="bobAddress" class="addr"></span><br>

            <span id="bobSharedSecret" class="addr"></span>

            <span id="bobBalance" class="balance"></span>
            <span id="bobGas" class="balance"></span>

            <fieldset role="group">
                <input type="number" id="bobAmount" placeholder="Amount to send" step="0.01" min="0" required>
                <input type="submit" value="Send to himself" />
            </fieldset>



        </div>




    </div>

    <!-- ------------ -->

    <div id="messagesResult"></div>
    <div class="col" id="result">
        <h3>RESULT:</h3>

    </div>

    <br><br>
    <div id="resultAddress"></div>
    <script src="js/ethers-6.13.2.umd.min.js"></script>


    <script type="module">

        import { getPublicKey, utils } from '@noble/secp256k1';
        import * as secp from '@noble/secp256k1';
        window.getPublicKey = getPublicKey;
        window.utils = utils;
        window.secp = secp;

    </script>


    <script>


        // --------------------------------------------------------
        optionsList = [
            {
                "TOKEN_CHAIN_NAME": 'Arbitrum sepolia',
                "TOKEN_CHAINID": '421614',
                "ERC20_TOKEN_CONTRACT": "0xFb1cb5a6dADDcE008d86f72057265A3afC82d539",
                "ERC20_TOKEN_NAME": "PDTROK",
                "ERC20_TOKEN_ABI": 'PermitDeadlineTokenv2',
                "EXPLORER": 'https://sepolia.arbiscan.io/',
                "API": 'https://arbitrum-sepolia.blockpi.network/v1/rpc/public',
                "ABI": ' [ { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [], "name": "AccessControlBadConfirmation", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "bytes32", "name": "neededRole", "type": "bytes32" } ], "name": "AccessControlUnauthorizedAccount", "type": "error" }, { "inputs": [], "name": "ECDSAInvalidSignature", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "length", "type": "uint256" } ], "name": "ECDSAInvalidSignatureLength", "type": "error" }, { "inputs": [ { "internalType": "bytes32", "name": "s", "type": "bytes32" } ], "name": "ECDSAInvalidSignatureS", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "allowance", "type": "uint256" }, { "internalType": "uint256", "name": "needed", "type": "uint256" } ], "name": "ERC20InsufficientAllowance", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "balance", "type": "uint256" }, { "internalType": "uint256", "name": "needed", "type": "uint256" } ], "name": "ERC20InsufficientBalance", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "approver", "type": "address" } ], "name": "ERC20InvalidApprover", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "receiver", "type": "address" } ], "name": "ERC20InvalidReceiver", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" } ], "name": "ERC20InvalidSender", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" } ], "name": "ERC20InvalidSpender", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "deadline", "type": "uint256" } ], "name": "ERC2612ExpiredSignature", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "signer", "type": "address" }, { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC2612InvalidSigner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "uint256", "name": "currentNonce", "type": "uint256" } ], "name": "InvalidAccountNonce", "type": "error" }, { "inputs": [], "name": "InvalidShortString", "type": "error" }, { "inputs": [ { "internalType": "string", "name": "str", "type": "string" } ], "name": "StringTooLong", "type": "error" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [], "name": "EIP712DomainChanged", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "indexed": true, "internalType": "bytes32", "name": "previousAdminRole", "type": "bytes32" }, { "indexed": true, "internalType": "bytes32", "name": "newAdminRole", "type": "bytes32" } ], "name": "RoleAdminChanged", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" } ], "name": "RoleGranted", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" } ], "name": "RoleRevoked", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [], "name": "DEFAULT_ADMIN_ROLE", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "DOMAIN_SEPARATOR", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "MAX_MINT_AMOUNT", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "VALIDATOR_ROLE", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" } ], "name": "allowance", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "approve", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [ { "internalType": "uint8", "name": "", "type": "uint8" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "eip712Domain", "outputs": [ { "internalType": "bytes1", "name": "fields", "type": "bytes1" }, { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "string", "name": "version", "type": "string" }, { "internalType": "uint256", "name": "chainId", "type": "uint256" }, { "internalType": "address", "name": "verifyingContract", "type": "address" }, { "internalType": "bytes32", "name": "salt", "type": "bytes32" }, { "internalType": "uint256[]", "name": "extensions", "type": "uint256[]" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" } ], "name": "getPermitDeadline", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" } ], "name": "getRoleAdmin", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "account", "type": "address" } ], "name": "grantRole", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "account", "type": "address" } ], "name": "hasRole", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "", "type": "address" } ], "name": "lastMintTimestamp", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "mint", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "nonces", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "uint256", "name": "deadline", "type": "uint256" }, { "internalType": "uint8", "name": "v", "type": "uint8" }, { "internalType": "bytes32", "name": "r", "type": "bytes32" }, { "internalType": "bytes32", "name": "s", "type": "bytes32" } ], "name": "permit", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "callerConfirmation", "type": "address" } ], "name": "renounceRole", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "account", "type": "address" } ], "name": "revokeRole", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes4", "name": "interfaceId", "type": "bytes4" } ], "name": "supportsInterface", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transfer", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" } ] '

            },
            {
                "TOKEN_CHAIN_NAME": 'Sepolia',
                "TOKEN_CHAINID": '11155111',
                "ERC20_TOKEN_CONTRACT": "0x247c1382D702A33a15E1d79e884A6e6eAB94CfbC",
                "ERC20_TOKEN_NAME": "MyTokenwidhDeadline",
                "ERC20_TOKEN_ABI": 'MyTokenwidhDeadline',
                "EXPLORER": 'https://sepolia.etherscan.io/',
                "API": 'https://ethereum-sepolia.publicnode.com',
                "ABI": ' [ { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [], "name": "ECDSAInvalidSignature", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "length", "type": "uint256" } ], "name": "ECDSAInvalidSignatureLength", "type": "error" }, { "inputs": [ { "internalType": "bytes32", "name": "s", "type": "bytes32" } ], "name": "ECDSAInvalidSignatureS", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "allowance", "type": "uint256" }, { "internalType": "uint256", "name": "needed", "type": "uint256" } ], "name": "ERC20InsufficientAllowance", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "balance", "type": "uint256" }, { "internalType": "uint256", "name": "needed", "type": "uint256" } ], "name": "ERC20InsufficientBalance", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "approver", "type": "address" } ], "name": "ERC20InvalidApprover", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "receiver", "type": "address" } ], "name": "ERC20InvalidReceiver", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" } ], "name": "ERC20InvalidSender", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" } ], "name": "ERC20InvalidSpender", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "deadline", "type": "uint256" } ], "name": "ERC2612ExpiredSignature", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "signer", "type": "address" }, { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC2612InvalidSigner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "uint256", "name": "currentNonce", "type": "uint256" } ], "name": "InvalidAccountNonce", "type": "error" }, { "inputs": [], "name": "InvalidShortString", "type": "error" }, { "inputs": [ { "internalType": "string", "name": "str", "type": "string" } ], "name": "StringTooLong", "type": "error" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [], "name": "EIP712DomainChanged", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [], "name": "DOMAIN_SEPARATOR", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" } ], "name": "INFINITEallowanceLOCAL", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" } ], "name": "allowance", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "approve", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [ { "internalType": "uint8", "name": "", "type": "uint8" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "eip712Domain", "outputs": [ { "internalType": "bytes1", "name": "fields", "type": "bytes1" }, { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "string", "name": "version", "type": "string" }, { "internalType": "uint256", "name": "chainId", "type": "uint256" }, { "internalType": "address", "name": "verifyingContract", "type": "address" }, { "internalType": "bytes32", "name": "salt", "type": "bytes32" }, { "internalType": "uint256[]", "name": "extensions", "type": "uint256[]" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" } ], "name": "getPermitDeadline", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "mint", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "nonces", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "uint256", "name": "deadline", "type": "uint256" }, { "internalType": "uint8", "name": "v", "type": "uint8" }, { "internalType": "bytes32", "name": "r", "type": "bytes32" }, { "internalType": "bytes32", "name": "s", "type": "bytes32" } ], "name": "permit", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transfer", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" } ] '

            }
        ]


        erc20Abi = [
            "function totalSupply() view returns (uint256)",
            "function balanceOf(address account) view returns (uint256)",
            "function transfer(address recipient, uint256 amount) returns (bool)",
            "function transferFrom(address sender, address recipient, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)"  // Added the decimals function
        ];


        const toHexString = (bytes) => {
            return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
        };




        async function init() {
            console.log('init()')


            /**********************
             .) ALICE
            ************************/
            // Alice generates her one-time private key
            let alicewallet = await aliceWallet()
            const alicePrivateKeyA = alicewallet.privateKey;
            let alicePrivateKey = ethers.getBytes(alicePrivateKeyA);
            document.getElementById('aliceAddress').innerHTML = alicewallet.address

            let aliceGasBalance = await checkGasBalance(alicewallet.address)
            console.log('Alice GAS Balance:', aliceGasBalance)
            document.getElementById('aliceGas').innerHTML = `<br>Balance: ` + aliceGasBalance

            document.getElementById('aliceAmount').value = 0.01;
            document.getElementById('bobAmount').value = 0.01;

            // with @noble/secp256k1
            const alicePublicKey = getPublicKey(alicePrivateKey);
            // console.log('alicePublicKey (with @noble/secp256k1):',alicePublicKey)

            // with ethers
            let alicePublicKeyB = ethers.getBytes(alicewallet.publicKey);
            // console.log('alicePublicKey (with ethers ):',alicePublicKeyB)

            /**********************
             .) BOB
            ************************/
            // Bob's public key (can be retrieved or shared)
            let bobwallet = await bobWallet()
            const bobPrivKey = bobwallet.privateKey;
            let bobPrivateKey = ethers.getBytes(bobPrivKey);
            document.getElementById('bobAddress').innerHTML = bobwallet.address

            let bobGasBalance = await checkGasBalance(bobwallet.address)
            console.log('Bob GAS Balance:', bobGasBalance)
            document.getElementById('bobGas').innerHTML = `<br>Balance : ` + bobGasBalance

            let bobPublicKey = getPublicKey(bobPrivateKey);


            /**********************
             .) calculate stealth address
             ************************/
         
            //////////////////////////
            // ALICE GENERATES THE STEALTH ADDRESS
            //////////////////////////

            let stealthAddress = await generateStealthAddress(alicePrivateKey, bobPublicKey)
            result.innerHTML += `<br>👩👻Stealth address (generated by Alice to Bob): ${stealthAddress.stealthAddress}
            <br>👫sharedSecret: ${stealthAddress.sharedSecret}`

            //////////////////////////
            // BOB GENERATES THE STEALTH ADDRESS
            //////////////////////////
            let bobstealthAddress = await generateStealthAddress(bobPrivateKey, alicePublicKey)
            result.innerHTML += `<br><br>🧔👻Stealth address (generated by Bob to Alice): ${bobstealthAddress.stealthAddress}
            <br>👫sharedSecret: ${bobstealthAddress.sharedSecret}`

            /**********************
             .) claim?
             ************************/
            // Example: Bob checks and claims the transaction
            const checkResult = await checkStealthTransaction(bobPrivKey, stealthAddress.stealthAddress);

            if (checkResult) {
                console.warn("💰💰💰 Funds are ready to be claimed from the stealth address.");
                result.innerHTML +="<br><br> <ins>💰💰💰 Funds are ready to be claimed from the stealth address.</ins>";

            // return
                // claimFundsFromStealthAddress(bobwallet.privateKey, alicewallet.publicKey, bobwallet.address)
            } else {
                console.log("⛔⛔⛔💸No funds available or no action was taken.");
                result.innerHTML +=" <br><br>⛔⛔⛔💸No funds available or no action was taken.";
            }


            // check bob private key generates the same stealth address
            createStealthWallet(bobwallet.privateKey, alicewallet.publicKey)
            // return 
            // if (bobStealthWallet.address.toLowerCase() === stealthAddressBob.toLowerCase()) {
            //     console.log("✅ Stealth addresses match!");
            // } else {
            //     console.error("❌ Stealth addresses do not match!");
            // }

            // return 

        }

        init()






        // -----------------------------------------
        // CHECK STEALTH TX
        // -----------------------------------------



        async function checkStealthTransaction(bobPrivateKeyHex, stealthAddress) {

            let provider = await new ethers.JsonRpcProvider(optionsList[0].API);
            const bobWallet = new ethers.Wallet(bobPrivateKeyHex, provider);
            console.warn('bobWallet.address:', bobWallet.address)
            const balance = await provider.getBalance(stealthAddress);
            console.log(`Stealth address (${stealthAddress})balance:`, ethers.formatEther(balance));
            if (balance > 0) {
                console.log("Stealth address has received funds!");
                const tx = {
                    to: bobWallet.address, // Bob's actual address
                    value: balance
                };
                try {
                    gasEstimate = await provider.estimateGas(tx);
                    console.log("Claiming fund gas estimation:", gasEstimate);
                } catch (error) {
                    console.error("Error simultating claiming funds:", error);
                }
                console.warn(`Estimated Gas needed : ${gasEstimate.toString()}`);
                result.innerHTML += `<br><br><ins>Estimated Gas needed to claim : ${gasEstimate.toString()}</ins>`
                return true
            } else {
                console.log("No funds available in the stealth address.");
                return false
            }


        }








        // -----------------------------------------
        // NEW STEALTH ADDRESS FUNCTIONS
        // -----------------------------------------
        // async function generateSharedSecret(aliceorbobPrivateKey, boboralicePublicKey) {
        //     // Alice generates the shared secret and stealth address
        //     const privateKeyHex = `0x${toHexString(aliceorbobPrivateKey)}`;
        //     const pubPoint = secp.ProjectivePoint.fromHex(boboralicePublicKey);
        //     const sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();
        //     console.log('👫sharedSecret():', sharedSecret);
        //     const hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);
        //     hs = hashedSecret
        //     return hashedSecret
        // }

        async function generateStealthAddress(privateKey, publicKey) {
            console.warn('🏰 generateStealthAddress()')
            const privateKeyHex = `0x${toHexString(privateKey)}`;
            const pubPoint = secp.ProjectivePoint.fromHex(publicKey);
            const sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();
            console.log('👫sharedSecret( at generateStealthAddress):', sharedSecret);
            const hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);

            // 1.Multiply hs by the curve generator point (G): You can use the secp256k1 generator point (which is a constant) to compute the point hs * G.
            const G = secp.ProjectivePoint.BASE;  // Generator point G
            const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
            const hsPoint = G.multiply(hsBigInt);  // hs * G
            hsp = hsPoint

            // 2.Add Bob’s public key: You now add Bob’s public key as an elliptic curve point to hs * G. Ensure Bob's public key is in the correct format for the addition.
            const point = secp.ProjectivePoint.fromHex(publicKey);  // Bob's public key point
            const stealthPubPoint = hsPoint.add(point);  // hs * G + Bob's public key
            p1 = point
            p2 = stealthPubPoint

            // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
            const stealthPubKey = stealthPubPoint.toHex();  // Convert to hex
            const stealthAddress = ethers.computeAddress('0x' + stealthPubKey);  // Convert to Ethereum address
            console.log('👻Stealth Address:', stealthAddress);
            return { stealthAddress, sharedSecret }
        }

        function removeHexPrefix(hexString) {
            // Check if the hex string starts with '0x' and remove it
            if (hexString.startsWith('0x')) {
                return hexString.slice(2);
            }
            return hexString;
        }



        // -----------------------------------------
        // STEALTH ADDRESS FUNCTIONS
        // -----------------------------------------



        async function createStealthWallet(privateKey, publicKey) {

            console.warn('createStealthWallet()', privateKey, publicKey)
            const publicKeyHexWithoutPrefix = removeHexPrefix(publicKey);
            privkw = publicKeyHexWithoutPrefix
            const pubPoint = secp.ProjectivePoint.fromHex(publicKeyHexWithoutPrefix);
            // console.log('pubPoint: ', pubPoint)
            const sharedSecret = pubPoint.multiply(BigInt(privateKey)).toHex();
            console.log('👫sharedSecret  (at createStealthWallet ):', sharedSecret);
            const hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);
            hsx = hashedSecret


            // BOB can comput the private key to the stealth addres
            // b +hs
            const hprivkeyBigInt = BigInt(privateKey);  // hs should already be in hex or BigInt format
            b = hprivkeyBigInt

            const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
            hs = hsBigInt

            computedPrivKey = hprivkeyBigInt + hsBigInt

            console.warn('🛰️ computedPrivKey: ', computedPrivKey)


            // return 

            // const stealthPrivateKey = ethers.utils.hexZeroPad(ethers.BigNumber.from(BigInt(b + hs)).toHexString(), 32);

            // const stealthPrivateKey =  ethers.zeroPadValue(ethers.BigNumber.from(BigInt(privateKey+ hashedSecret)).toHexString(), 32)

            eth2bigint = ethers.toBigInt(computedPrivKey)

            //  const stealthPrivateKey =  ethers.zeroPadValue(ethers.toBigInt(computedPrivKey).toHexString(), 32)
            //  const stealthPrivateKey =  ethers.zeroPadValue(ethers.toBigInt(computedPrivKey).toHexString(), 32)
            const stealthPrivateKey = ethers.zeroPadValue(ethers.toBeHex(computedPrivKey), 32);

            console.warn(' 🚁 stealthPrivateKey: ', stealthPrivateKey)

            const wallet = new ethers.Wallet(stealthPrivateKey);
            const derivedStealthPubKey = wallet.publicKey;
            console.warn(' 🪂 stealthPrivateKey: ', stealthPrivateKey)
            console.warn(' 🪂 stealthAddress: ', wallet.address)


            return


            // NOW (b +hs) x G
            // 1.Multiply hs by the curve generator point (G): 
            // You can use the secp256k1 generator point (which is a constant) to compute the point hs * G.
            const G = secp.ProjectivePoint.BASE;  // Generator point G
            g = G
            const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
            hs = hsBigInt
            const hprivkeyBigInt = BigInt(privateKey);  // hs should already be in hex or BigInt format
            b = hprivkeyBigInt
            bhs = hprivkeyBigInt + hsBigInt





            return
            const hsPoint = G.multiply(bhs)
            // g.multiply(BigInt(hs) + BigInt(b))
            // console.warn('hsPoint:', hsPoint)




            // 2.Add Bob’s public key: You now add Bob’s public key as an elliptic curve point to hs * G. Ensure Bob's public key is in the correct format for the addition.
            const point = secp.ProjectivePoint.fromHex(publicKeyHexWithoutPrefix);  // Bob's public key point
            const stealthPubPoint = hsPoint.add(point);  // hs * G + Bob's public key
            // console.warn('🆙stealthPubPoint :', stealthPubPoint);

            // return

            // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
            const stealthPubKey = stealthPubPoint.toHex();  // Convert to hex
            // console.log('🚀stealthPubKey:', stealthPubKey);
            // spubpk = stealthPubKey
            const stealthAddress = ethers.computeAddress('0x' + stealthPubKey);  // Convert to Ethereum address
            console.log('🛸SOME Address?!:', stealthAddress);
            return



        }








        // Function to calculate the stealth private key using noble-secp256k1
        // async function calculateStealthPrivateKey(bobPrivateKeyHex, sharedSecretHex) {

        //     const bobPrivateKeyHexWithoutPrefix = removeHexPrefix(bobPrivateKeyHex);
        //     const sharedSecretHexWithoutPrefix = removeHexPrefix(sharedSecretHex);


        //     // Convert hex strings to byte arrays
        //     const bobPrivateKeyBytes = secp.etc.hexToBytes(bobPrivateKeyHexWithoutPrefix);
        //     const sharedSecretBytes = secp.etc.hexToBytes(sharedSecretHexWithoutPrefix);


        //     // Convert byte arrays to BigInts
        //     const bobPrivateKeyBigInt = BigInt(`0x${bobPrivateKeyHexWithoutPrefix}`);
        //     const sharedSecretBigInt = BigInt(`0x${sharedSecretHexWithoutPrefix}`);

        //     // Perform the elliptic curve operation
        //     const curveOrder = secp.CURVE.n;
        //     const stealthPrivateKeyBigInt = (bobPrivateKeyBigInt + sharedSecretBigInt) % curveOrder;

        //     // st = stealthPrivateKeyBigInt
        //     console.log('stealthPrivateKeyBigInt: ', stealthPrivateKeyBigInt)

        //     // Convert the resulting BigInt to a hex string
        //     const stealthPrivateKeyHex = stealthPrivateKeyBigInt.toString(16).padStart(64, '0');
        //     console.log('🧔👻👻👻 computed private key  at calculateStealthPrivateKey :', stealthPrivateKeyHex);

        //     // return  `0x${stealthPrivateKeyHex}`

        //     // pk = stealthPrivateKeyHex
        //     // Return the result
        //     // return stealthPrivateKeyHex;

        //     // const privateKeyHex = '1ccff508c8c7e4b7e9365b8d1f549efbbb8aa640a72be110d297e1f4586cb1b4';
        //     const wallet = new ethers.Wallet(`0x${stealthPrivateKeyHex}`);

        //     console.log('👻👻👻Corresponding stealth Address:', wallet.address);
        //     return  wallet
        // }


        async function claimFundsFromStealthAddress(bobPrivateKeyHex, alicePublicKeyHex, bobMainAddr) {
            console.log('claimFundsFromStealthAddress()')
            let provider = await new ethers.JsonRpcProvider(optionsList[0].API);

            let stealthPrivateKey = computePrivateKey(bobPrivateKeyHex,alicePublicKeyHex)


            // Create a wallet for the stealth address
            const stealthWallet = new ethers.Wallet(stealthPrivateKey, provider);
            console.log(`👻👻👻Stealth Wallet Address: ${stealthWallet.address}`);



            return


            // The stealth wallet address should match the stealth address Bob calculated earlier
            if (bobStealthWallet.address.toLowerCase() === stealthAddressBob.toLowerCase()) {
                console.log("✅ Stealth addresses match!");
            } else {
                console.error("❌ Stealth addresses do not match!");
            }
            return




            // Bob's main address where he wants to send the funds
            const bobMainAddress = bobMainAddr; // Bob's regular address

            // Check the balance of the stealth address
            const balance = await provider.getBalance(bobStealthWallet.address);
            console.log(`BOB sStealth address(${bobStealthWallet.address}) balance:`, ethers.formatEther(balance));//esta mal

            return
            // If there are funds in the stealth address, send them to Bob's main address
            if (balance > 0) {
                console.log("Stealth address has received funds!");

                // Define the transaction to send the funds to Bob's main address
                const tx = {
                    to: bobMainAddress, // Bob's main address
                    value: balance.sub(ethers.parseUnits("0.001", "ether")), // Subtracting gas fee for the transaction
                    gasLimit: 21000, // Standard gas limit for ETH transfer
                };

                try {
                    // Bob sends the funds to his main address from the stealth address
                    const txResponse = await bobStealthWallet.sendTransaction(tx);
                    console.log("Transaction sent:", txResponse.hash);

                    // Wait for the transaction to be confirmed
                    const receipt = await txResponse.wait();
                    console.log("Transaction confirmed:", receipt);
                } catch (error) {
                    console.error("Transaction error:", error);
                }
            } else {
                console.log("No funds available in the stealth address.");
            }
        }





        // -----------------------------------------
        // BALANCE FUNCTIONS
        // -----------------------------------------

        async function checkGasBalance(userAddress) {
            console.log('checkGasBalance() of ', userAddress)
            let provider = await new ethers.JsonRpcProvider(optionsList[0].API);

            try {
                const balance = await provider.getBalance(userAddress);
                const gasBalance = ethers.formatEther(balance);
                console.log(`GAS Balance: ${gasBalance} `);

                return gasBalance;
            } catch (error) {
                console.error('Error checking balance:', error.reason);
                return null;
            }
        }

        // -----------------------------------------
        // WALLET FUNCTIONS
        // -----------------------------------------


        // Function to derive an address on demand
        async function deriveAddressWallet(mnemonic, index) {
            const basePath = "m/44'/60'/0'/0/";
            const path = `${basePath}${index}`;
            const derivedNode = ethers.HDNodeWallet.fromPhrase(mnemonic, path);
            return derivedNode
        }

        async function aliceWallet() {
            let aliceMnemonic = localStorage.getItem('aliceMnemonic');
            if (!aliceMnemonic) {
                console.error('NO aliceMnemonic  in localStorage!');

                const randmnemonic = await ethers.HDNodeWallet.createRandom()
                aliceMnemonic = randmnemonic.mnemonic.phrase;
                localStorage.setItem('aliceMnemonic', aliceMnemonic);

            } else {
                console.log('aliceMnemonic is in localStorage!');

            }
            let aliceWall = deriveAddressWallet(aliceMnemonic, 0)
            return aliceWall
        }

        // 1- GET  PRIV KEY(IF not CREATE IT)
        async function bobWallet() {
            let bobMnemonic = localStorage.getItem('bobMnemonic');
            if (!bobMnemonic) {
                console.error('NO bobMnemonic  in localStorage!');

                const randmnemonic = await ethers.HDNodeWallet.createRandom()
                bobMnemonic = randmnemonic.mnemonic.phrase;
                console.log(bobMnemonic)
                localStorage.setItem('bobMnemonic', bobMnemonic);

            } else {
                console.log('bobMnemonic is in localStorage!');

            }

            let bobWall = deriveAddressWallet(bobMnemonic, 0)
            return bobWall

        }


        // -----------------------------------------
        // SEND TX FUNCTIONS
        // -----------------------------------------



        // Listen for button click
        document.getElementById("sendButton").addEventListener("click", async () => {
            // await connectWallet();  // Connect to MetaMask
            await sendTransaction(); // Send the transaction
        });



        async function sendTransaction() {


            let provider = await new ethers.JsonRpcProvider(optionsList[0].API);
            let alicewallet = await aliceWallet()
            const aliceWalletWithProvider = alicewallet.connect(provider);
            const alicePrivateKeyA = alicewallet.privateKey;
            let alicePrivateKey = ethers.getBytes(alicePrivateKeyA);
            const amountToSend = document.getElementById("aliceAmount").value;
            let bobwallet = await bobWallet()
            const bobPrivKey = bobwallet.privateKey;
            let bobPrivateKey = ethers.getBytes(bobPrivKey);
            let bobPublicKey = getPublicKey(bobPrivateKey);
            let stealthAddress = await generateStealthAddress(alicePrivateKey, bobPublicKey)

            if (!amountToSend || amountToSend <= 0) {
                alert("Please enter a valid amount.");
                return;
            }

            const tx = {
                to: stealthAddress,
                value: ethers.parseEther(amountToSend), // Amount in ETH
            };

            console.log('about to send ', tx)
            try {
                const txResponse = await aliceWalletWithProvider.sendTransaction(tx);
                console.log("Transaction sent:", txResponse.hash);
                const receipt = await txResponse.wait();
                console.log("Transaction confirmed:", receipt);

            } catch (error) {
                console.error("Transaction error:", error);
            }
        }



        async function sendFromStealthToBob(stealthPrivateKey) {
            try {
                // Assuming aliceStealthWallet is already derived from the stealth address
                let aliceStealthWallet = await ethers.Wallet.fromPrivateKey(stealthPrivateKey);

                // Attach a provider to the stealth wallet so it can interact with the network
                const provider = new ethers.BrowserProvider(window.ethereum); // MetaMask provider or Infura, etc.
                aliceStealthWallet = aliceStealthWallet.connect(provider);

                // Bob's current address (destination)
                const bobAddress = "0xBobCurrentAddress"; // Replace with Bob's actual address

                // Get balance of Alice's stealth wallet to send (You can also specify a specific amount)
                const balance = await aliceStealthWallet.getBalance();
                console.log("Stealth wallet balance:", ethers.formatEther(balance));

                // Create transaction object
                const tx = {
                    to: bobAddress,          // Bob's current address
                    value: balance,          // Amount of ETH to send (here it's all balance)
                    gasLimit: undefined      // Will be estimated next
                };

                // Estimate gas required for the transaction
                const gasEstimate = await provider.estimateGas(tx);
                console.log("Estimated gas:", gasEstimate.toString());

                // Set the gasLimit with an additional buffer of 10000
                tx.gasLimit = gasEstimate + BigInt(10000);

                // Send transaction from stealth wallet to Bob's current address
                const txResponse = await aliceStealthWallet.sendTransaction(tx);
                console.log("Transaction sent:", txResponse.hash);

                // Wait for confirmation
                const receipt = await txResponse.wait();
                console.log("Transaction confirmed:", receipt);
            } catch (error) {
                console.error("Error sending funds from stealth to Bob:", error);
            }
        }



    </script>
</body>

</html>